<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
<div id="page">

<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/cover.jpeg)">
  <div class="overlay">
  <div class="featured">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>John Doe</span>
    <h1>Hexo</h1>
    
    
  </div>
  </div>
</div>

<div id="lx-main-content">
  <div class="lx-post">

  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/28/Class%E6%80%BB%E7%BB%93/">Class总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-28</span>
      <p><h3 id="Class类的由来"><a href="#Class类的由来" class="headerlink" title="Class类的由来"></a>Class类的由来</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Point(1, 2);</span><br></pre></td></tr></table></figure>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数Point是一致的。</p>
<p>Point类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor()方法。</p>
<p>constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    return Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>上面代码中，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    return Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line">&#x2F;&#x2F; TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure>
<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">var point &#x3D; Point(2, 3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">var point &#x3D; new Point(2, 3);</span><br></pre></td></tr></table></figure>
<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类</span><br><span class="line">class Point &#123;</span><br><span class="line"></span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point &#x3D; new Point(2, 3);</span><br><span class="line"></span><br><span class="line">point.toString() &#x2F;&#x2F; (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class="line">point.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line">point.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line">point.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty()方法返回true，而toString()是原型对象的属性（因为定义在Point类上），所以hasOwnProperty()方法返回false。这些都与 ES5 的行为保持一致。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__ &#x3D;&#x3D;&#x3D; p2.__proto__</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p>
<p>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</p>
<p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Point(4,2);</span><br><span class="line">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &#39;getter&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&#39;setter: &#39;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst &#x3D; new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">&#x2F;&#x2F; &#39;getter&#39;</span><br></pre></td></tr></table></figure>
<p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.element &#x3D; element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get html() &#123;</span><br><span class="line">    return this.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set html(value) &#123;</span><br><span class="line">    this.element.innerHTML &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var descriptor &#x3D; Object.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, &quot;html&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&quot;get&quot; in descriptor  &#x2F;&#x2F; true</span><br><span class="line">&quot;set&quot; in descriptor  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。</p>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let methodName &#x3D; &#39;getArea&#39;;</span><br><span class="line"></span><br><span class="line">class Square &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass &#x3D; class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/28/Class%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/28/hook%E6%80%BB%E7%BB%93/">hook总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-28</span>
      <p><h1 id="Hook-钩子"><a href="#Hook-钩子" class="headerlink" title="Hook (钩子)"></a>Hook (钩子)</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>React Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。<br>React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。<br>这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。<br>它可以让你在不编写class 的情况下使用state以及其他的React特性。（比如生命周期、ref等类组件拥有的特性）</p>
<ul>
<li><p>基础Hook:</p>
<p>  useState 给函数组件添加内部state<br>  useEffect 可以让你在函数组件中执行副作用操作<br>  useContext 组件间数据共享更轻松</p>
</li>
<li><p>额外Hook：</p>
<p>  useReducer 替代useState统一管理数据状态<br>  useRef<br>  useCallback<br>  useMemo</p>
</li>
</ul>
<h2 id="一个简单的Hook："><a href="#一个简单的Hook：" class="headerlink" title="一个简单的Hook："></a>一个简单的Hook：</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个叫 &quot;count&quot; 的 state 变量</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;</span><br><span class="line">          点击加1</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>useState</strong> 是我们要学习的第一个 “Hook”，这个例子是简单演示。</p>
<ul>
<li><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>  通过函数组件来调用它来给组件添加一些<strong>内部state</strong>。React在重新渲染时保留这个state,useState会返回一对值：当前状态和一个让你更新它的函数，它类似class组件的this.setState,但是它不会把新的state和旧的state进行合并。<br>  useState唯一的参数就是初始state。</p>
<p>  语法：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [num, setNum] &#x3D; useState(0)；</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>  你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为”副作用”，或者简称为”作用”</p>
<p>  useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <strong>componentDidMount</strong>、<strong>componentDidUpdate</strong> 和 <strong>componentWillUnmount</strong> 具有相同的用途，只不过被合并成了一个 API。</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个叫 &quot;count&quot; 的 state 变量</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">      &#x2F;&#x2F; 相当于 componentDidMount 和 componentDidUpdate:</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">        document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;</span><br><span class="line">            点击加1</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>  接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。</p>
<p>  是用来解决组件通信，用法：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value &#x3D; useContext(MyContext);</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>  useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。</p>
<p>  在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数。</p>
</li>
</ul>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/28/hook%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/25/promise%E6%80%BB%E7%BB%93/">promise总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-25</span>
      <p><p>hello！</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/25/promise%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/25/hello-world/">Hello World</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-25</span>
      <p><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/25/hello-world/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>




<footer>
  <div>
  Copyright &copy; 2020.<a href="/">Hexo</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

  </div>
</div>
</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="John Doe"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>John Doe</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
