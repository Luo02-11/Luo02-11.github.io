<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
<div id="page">

<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/cover.jpeg)">
  <div class="overlay">
  <div class="featured">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>John Doe</span>
    <h1>Hexo</h1>
    
    
  </div>
  </div>
</div>

<div id="lx-main-content">
  <div class="lx-post">

  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/01/12/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%80%BB%E7%BB%93/">深浅拷贝总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-01-12</span>
      <p><h2 id="JavaScript深浅拷贝"><a href="#JavaScript深浅拷贝" class="headerlink" title="JavaScript深浅拷贝"></a>JavaScript深浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><ul>
<li>浅拷贝：只是简单的复制引用，并没有真正的值，彼此之间会有影响（拷贝对象会随着目标对象改变而改变）。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const oneObj &#x3D; [1,2,3];</span><br><span class="line">const towObj &#x3D; &#123;name:&#39;你猜&#39;,b:&#39;b&#39;,c:[1,2,3]&#125;;</span><br><span class="line"></span><br><span class="line">const cloneOne &#x3D; oneObj;</span><br><span class="line">const cloneTwo &#x3D; towObj;</span><br><span class="line"></span><br><span class="line">console.log(cloneOne); &#x2F;&#x2F; [1,2,3]</span><br><span class="line">console.log(towObj); &#x2F;&#x2F; &#123;name:&#39;你猜&#39;,b:&#39;b&#39;,c:Array[3]&#125;</span><br><span class="line"></span><br><span class="line">cloneOne.push(4);</span><br><span class="line">cloneTwo.name &#x3D; &#123;aa:&#39;aa&#39;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(cloneOne); &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">console.log(oneObj); &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line"></span><br><span class="line">console.log(cloneTwo); &#x2F;&#x2F; &#123;name:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3]&#125;</span><br><span class="line">console.log(oneObj); &#x2F;&#x2F; &#123;name:&#123;aa:&#39;aa&#39;&#125;,b:&#39;b&#39;,c:Array[3]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>concat()方法:该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。（只是对数组的第一层进行深拷贝，都不会修改原数组，而是返回一个修改后的新数组）</p>
</li>
<li><p>slice()方法：该方法不传值将会截取整个字段。（只是对数组的第一层进行深拷贝，都不会修改原数组，而是返回一个修改后的新数组）</p>
</li>
<li><p>Object.assign()方法：拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p>
</li>
<li><p>…展开运算符方法：实现的是对象第一层的深拷贝，后面的只是拷贝的引用值。</p>
</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li><p>深拷贝：对目标的完全拷贝，值是相同的，互不影响（目标对象改变不影响拷贝后的对象）。</p>
</li>
<li><p>JSON的stringify/parse方法：<br>（1）JSON.stringify 是将一个 JavaScript 值转成一个 JSON 字符串。<br>（2）JSON.parse 是将一个 JSON 字符串转成一个 JavaScript 值或对象。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const firstObj &#x3D; &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3],d:&#123;dSon:&#39;son&#39;&#125;&#125;;</span><br><span class="line">const cloneObj &#x3D; JSON.parse(JSON.stringify(firstObj));</span><br><span class="line">console.log(cloneObj &#x3D;&#x3D;&#x3D; firstObj); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">cloneObj.a &#x3D; &#39;aa&#39;;</span><br><span class="line">cloneObj.c &#x3D; [1,1,1];</span><br><span class="line">cloneObj.d.dSon &#x3D; &#39;brother&#39;;</span><br><span class="line"></span><br><span class="line">console.log(cloneObj); &#x2F;&#x2F; &#123;a:&#39;aa&#39;,b:&#39;b&#39;,c:[1,1,1],d:&#123;dSon:&#39;brother&#39;&#125;&#125;;</span><br><span class="line">console.log(firstObj); &#x2F;&#x2F; &#123;a:&#39;a&#39;,b:&#39;b&#39;,c:[1,2,3],d:&#123;dSon:&#39;son&#39;&#125;</span><br></pre></td></tr></table></figure></p>
      <div class="post-button"><a class="btn" href="/2021/01/12/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/01/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%80%BB%E7%BB%93/">原型链总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-01-11</span>
      <p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><ul>
<li>什么是原型链？  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有原型，原型也是对象，原型也有原型，所以形成了原型链。</span><br></pre></td></tr></table></figure></li>
<li>原型链作用：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象访问成员是规则：如果对象访问某个成员 </span><br><span class="line">（1）先看自己有没有,如果有就访问自己的</span><br><span class="line">（2）如果没有就访问原型</span><br><span class="line">（3）如果原型也没有，就沿着原型链一直往上查找，直到找到为止，如果找到头还没有找到，就返回undefined或报错</span><br></pre></td></tr></table></figure>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="（1）混入式继承"><a href="#（1）混入式继承" class="headerlink" title="（1）混入式继承"></a>（1）混入式继承</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let first&#x3D;&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">        name:&#39;小白&#39;,</span><br><span class="line">        phone:123456</span><br><span class="line">    &#125;,</span><br><span class="line">    msg:&#123;</span><br><span class="line">        sex:&#39;男&#39;</span><br><span class="line">        age:18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let second&#x3D;&#123;</span><br><span class="line">    people:[&#39;小明&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果second这个对象想有first对象的所有属性</span><br><span class="line">for(let key in wang)&#123;</span><br><span class="line">    second[key]&#x3D;first[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）替换原型式继承"><a href="#（2）替换原型式继承" class="headerlink" title="（2）替换原型式继承"></a>（2）替换原型式继承</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &#39;小白&#39;,</span><br><span class="line">    age: 15</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function New() &#123;</span><br><span class="line">    New.prototype.say &#x3D; function () &#123; console.log(&#96;我是$&#123;this.name&#125;&#96;) &#125;</span><br><span class="line">    console.log(&#39;hello world&#39;)</span><br><span class="line">&#125;</span><br><span class="line">New.prototype &#x3D; obj</span><br><span class="line">let newObj &#x3D; new New()</span><br><span class="line">newObj.say()</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></table></figure>
<h3 id="（3）混合式原型继承"><a href="#（3）混合式原型继承" class="headerlink" title="（3）混合式原型继承"></a>（3）混合式原型继承</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let obj&#x3D;&#123;</span><br><span class="line">    user:&#123;</span><br><span class="line">        name:&#39;小白&#39;,</span><br><span class="line">        phone:123456</span><br><span class="line">    &#125;,</span><br><span class="line">    msg:&#123;</span><br><span class="line">        sex:&#39;男&#39;</span><br><span class="line">        age:18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;准备一个构造函数</span><br><span class="line">function constructor(gfs) &#123;  </span><br><span class="line">    this.gfs &#x3D; gfs;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每一个对象都有一个方法. </span><br><span class="line">constructor.prototype.newObj &#x3D; function()&#123;</span><br><span class="line">    console.log(&#39;你是最棒的&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们希望每一个constructor实例化对象,都能拥有obj这个对象的成员,那就要继承</span><br><span class="line">for(let key in obj)&#123;</span><br><span class="line">    constructor.prototype[key] &#x3D; obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例化一个对象</span><br><span class="line">let data &#x3D; new constructor([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]);</span><br><span class="line">console.log(data);</span><br></pre></td></tr></table></figure></li>
</ul>
</p>
      <div class="post-button"><a class="btn" href="/2021/01/11/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/29/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/">TypeScript知识点</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-29</span>
      <p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>介绍：为了让程序有价值，外卖需要能够处理最简单的数据单元：数字、字符串、布尔值、结构体等。TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了使用的枚举类型方便我们使用。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let Flag:boolean &#x3D; false;</span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数学都是浮点数。这些浮点数的类型是number。除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral:number &#x3D; 6;</span><br><span class="line">let hexLiteral:number &#x3D; 0xf00d;</span><br><span class="line">let binaryLiteral:number &#x3D; 0b1010;</span><br><span class="line">let octalLiteral:number &#x3D; 0o744;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文字数据。像其它语言里一样，我们使用string表示文本数据类型。和JavaScript一样，可以使用双引号或单引号表示字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name:string &#x3D; &quot;你好&quot;；</span><br><span class="line">name &#x3D; &quot;string&quot;</span><br></pre></td></tr></table></figure>
<p>你还可以使用模板字符串，她可以定义多行文本和内嵌表达式。这种字符串是被反引号包这的 `` ,并且以${  }这中形式嵌入表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name: string &#x3D; &#39;Gai&#39;;</span><br><span class="line">let age: number &#x3D; 31;</span><br><span class="line">let sentence: string &#x3D; &#96;Hello, my name is $&#123; name &#125;,I&#39;ll be $&#123; age + 1 &#125; years old next month.&#96;;</span><br></pre></td></tr></table></figure>
<p>这与下面定义sentence的方式效果相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sentence: string &#x3D; &quot;Hello, my name is &quot; + name + &quot;.\n\n&quot; + &quot;I&#39;ll be &quot; + (age + 1) + &quot; years old next month.&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: number[] &#x3D; [1, 2, 3];</span><br></pre></td></tr></table></figure>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: Array&lt;number&gt; &#x3D; [1, 2, 3];</span><br></pre></td></tr></table></figure>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如:你可以定义一对值分别为 string和number类型的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x: [string, number];</span><br><span class="line"></span><br><span class="line">x &#x3D; [&#39;hello&#39;, 6]; &#x2F;&#x2F; OK</span><br><span class="line">x &#x3D; [6, &#39;hello&#39;]; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(x[0].substr(1)); &#x2F;&#x2F; OK</span><br><span class="line">console.log(x[1].substr(1)); &#x2F;&#x2F; Error, &#39;number&#39; does not have &#39;substr&#39;</span><br></pre></td></tr></table></figure>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x[3] &#x3D; &#39;world&#39;; &#x2F;&#x2F; OK, 字符串可以赋值给(string | number)类型</span><br><span class="line"></span><br><span class="line">console.log(x[5].toString()); &#x2F;&#x2F; OK, &#39;string&#39; 和 &#39;number&#39; 都有 toString</span><br><span class="line"></span><br><span class="line">x[6] &#x3D; true; &#x2F;&#x2F; Error, 布尔不是(string | number)类型</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color &#x3D; Color.Green;</span><br></pre></td></tr></table></figure>
<p>也可以手动的指定成员的数值并且可以全部都采用手动赋值,例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red &#x3D; 1, Green, Blue&#125; || enum Color &#123;Red &#x3D; 1, Green &#x3D; 2, Blue &#x3D; 4&#125;</span><br><span class="line">let c: Color &#x3D; Color.Green;</span><br></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red &#x3D; 1, Green &#x3D; 2, Blue &#x3D; 4&#125;</span><br><span class="line">let colorName: string &#x3D; Color[2];</span><br><span class="line"></span><br><span class="line">console.log(colorName);  &#x2F;&#x2F; 显示&#39;Green&#39;因为上面代码里它的值是2</span><br></pre></td></tr></table></figure>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any &#x3D; 4;</span><br><span class="line">notSure &#x3D; &quot;maybe a string instead&quot;;</span><br><span class="line">notSure &#x3D; false; &#x2F;&#x2F; okay, definitely a boolean</span><br></pre></td></tr></table></figure>
<p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值， 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let notSure: any &#x3D; 4;</span><br><span class="line">notSure.ifItExists(); &#x2F;&#x2F; okay, ifItExists might exist at runtime</span><br><span class="line">notSure.toFixed(); &#x2F;&#x2F; okay, toFixed exists (but the compiler doesn&#39;t check)</span><br><span class="line"></span><br><span class="line">let prettySure: Object &#x3D; 4;</span><br><span class="line">prettySure.toFixed(); &#x2F;&#x2F; Error: Property &#39;toFixed&#39; doesn&#39;t exist on type &#39;Object&#39;.</span><br></pre></td></tr></table></figure>
<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] &#x3D; [1, true, &quot;free&quot;];</span><br><span class="line"></span><br><span class="line">list[1] &#x3D; 100;</span><br></pre></td></tr></table></figure>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void &#x3D; undefined;</span><br></pre></td></tr></table></figure>
<p>Null 和 Undefined</p>
<p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined &#x3D; undefined;</span><br><span class="line">let n: null &#x3D; null;</span><br></pre></td></tr></table></figure>
<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/29/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/28/Class%E6%80%BB%E7%BB%93/">Class总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-28</span>
      <p><h3 id="Class类的由来"><a href="#Class类的由来" class="headerlink" title="Class类的由来"></a>Class类的由来</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Point(x, y) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString &#x3D; function () &#123;</span><br><span class="line">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Point(1, 2);</span><br></pre></td></tr></table></figure>
<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p>
<p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数Point是一致的。</p>
<p>Point类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor()方法。</p>
<p>constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    return Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>上面代码中，constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    return Object.create(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line">&#x2F;&#x2F; TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</span><br></pre></td></tr></table></figure>
<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">var point &#x3D; Point(2, 3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">var point &#x3D; new Point(2, 3);</span><br></pre></td></tr></table></figure>
<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类</span><br><span class="line">class Point &#123;</span><br><span class="line"></span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var point &#x3D; new Point(2, 3);</span><br><span class="line"></span><br><span class="line">point.toString() &#x2F;&#x2F; (2, 3)</span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class="line">point.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class="line">point.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line">point.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty()方法返回true，而toString()是原型对象的属性（因为定义在Point类上），所以hasOwnProperty()方法返回false。这些都与 ES5 的行为保持一致。</p>
<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__ &#x3D;&#x3D;&#x3D; p2.__proto__</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p>
<p>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</p>
<p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Point(2,3);</span><br><span class="line">var p2 &#x3D; new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Point(4,2);</span><br><span class="line">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    return &#39;getter&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    console.log(&#39;setter: &#39;+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let inst &#x3D; new MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; setter: 123</span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line">&#x2F;&#x2F; &#39;getter&#39;</span><br></pre></td></tr></table></figure>
<p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CustomHTMLElement &#123;</span><br><span class="line">  constructor(element) &#123;</span><br><span class="line">    this.element &#x3D; element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get html() &#123;</span><br><span class="line">    return this.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set html(value) &#123;</span><br><span class="line">    this.element.innerHTML &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var descriptor &#x3D; Object.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, &quot;html&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&quot;get&quot; in descriptor  &#x2F;&#x2F; true</span><br><span class="line">&quot;set&quot; in descriptor  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。</p>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let methodName &#x3D; &#39;getArea&#39;;</span><br><span class="line"></span><br><span class="line">class Square &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const MyClass &#x3D; class Me &#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    return Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/28/Class%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/28/hook%E6%80%BB%E7%BB%93/">hook总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-28</span>
      <p><h1 id="Hook-钩子"><a href="#Hook-钩子" class="headerlink" title="Hook (钩子)"></a>Hook (钩子)</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>React Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。<br>React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。<br>这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。<br>它可以让你在不编写class 的情况下使用state以及其他的React特性。（比如生命周期、ref等类组件拥有的特性）</p>
<ul>
<li><p>基础Hook:</p>
<p>  useState 给函数组件添加内部state<br>  useEffect 可以让你在函数组件中执行副作用操作<br>  useContext 组件间数据共享更轻松</p>
</li>
<li><p>额外Hook：</p>
<p>  useReducer 替代useState统一管理数据状态<br>  useRef<br>  useCallback<br>  useMemo</p>
</li>
</ul>
<h2 id="一个简单的Hook："><a href="#一个简单的Hook：" class="headerlink" title="一个简单的Hook："></a>一个简单的Hook：</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个叫 &quot;count&quot; 的 state 变量</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;</span><br><span class="line">          点击加1</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>useState</strong> 是我们要学习的第一个 “Hook”，这个例子是简单演示。</p>
<ul>
<li><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>  通过函数组件来调用它来给组件添加一些<strong>内部state</strong>。React在重新渲染时保留这个state,useState会返回一对值：当前状态和一个让你更新它的函数，它类似class组件的this.setState,但是它不会把新的state和旧的state进行合并。<br>  useState唯一的参数就是初始state。</p>
<p>  语法：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [num, setNum] &#x3D; useState(0)；</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>  你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为”副作用”，或者简称为”作用”</p>
<p>  useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <strong>componentDidMount</strong>、<strong>componentDidUpdate</strong> 和 <strong>componentWillUnmount</strong> 具有相同的用途，只不过被合并成了一个 API。</p>
<p>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    &#x2F;&#x2F; 声明一个叫 &quot;count&quot; 的 state 变量</span><br><span class="line">    const [count, setCount] &#x3D; useState(0);</span><br><span class="line">      &#x2F;&#x2F; 相当于 componentDidMount 和 componentDidUpdate:</span><br><span class="line">    useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用浏览器的 API 更新页面标题</span><br><span class="line">        document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(0)&#125;&gt;</span><br><span class="line">            点击加1</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>  接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。</p>
<p>  是用来解决组件通信，用法：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value &#x3D; useContext(MyContext);</span><br></pre></td></tr></table></figure></li>
<li><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>  useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。</p>
<p>  在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数。</p>
</li>
</ul>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/28/hook%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/25/promise%E6%80%BB%E7%BB%93/">promise总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-25</span>
      <p><p>hello！</p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/25/promise%E6%80%BB%E7%BB%93/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2020/12/25/hello-world/">Hello World</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2020-12-25</span>
      <p><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</p>
      <div class="post-button"><a class="btn" href="/2020/12/25/hello-world/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>




<footer>
  <div>
  Copyright &copy; 2021.<a href="/">Hexo</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

  </div>
</div>
</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="John Doe"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>John Doe</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
